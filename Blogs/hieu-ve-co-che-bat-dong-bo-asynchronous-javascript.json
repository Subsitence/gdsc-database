{
  "rawContent": "<div class=\"post-body\" \"line-number\">\n    <figure>\n        <img\n                src=\"https://i.postimg.cc/28YRybpq/d6668078-23db-42d3-b311-ea0a97dbd6e6.gif\"\n                alt=\"Event loop và Callback queue\"\n        />\n        <figcaption>Asynchronous JavaScript</figcaption>\n    </figure>\n\n    <h1 id=\"gioi-thieu\">Giới thiệu</h1>\n\n    <p>\n        <strong>JavaScript</strong> là một ngôn ngữ lập trình đơn luồng có nghĩa là\n        chỉ có một điều có thể xảy ra tại một thời điểm. Tức là, JavaScript engine\n        chỉ có thể xử lý một câu lệnh tại một thời điểm trong một luồng duy nhất.\n    </p>\n\n    <p>\n        Mặc dù ngôn ngữ đơn luồng đơn giản hóa việc viết code do bạn không cần lo\n        lắng về các vấn đề tương tranh, điều này cũng có nghĩa là bạn không thể thực\n        hiện các tác vụ dài như truy cập mạng mà không chặn luồng chính.\n    </p>\n\n    <p>\n        Hãy tưởng tượng bạn request dữ liệu từ một API. Tùy thuộc vào tình hình máy\n        chủ có thể mất một thời gian để xử lý request trong khi chặn luồng chính làm\n        cho trang web không hồi đáp.\n    </p>\n\n    <p>\n        Đó là lý do asynchronous JavaScript xuất hiện. Sử dụng asynchronous\n        JavaScript (callbacks, promises, and async/await) bạn có thể thực hiện các\n        request network dài mà không chặn luồng chính.\n    </p>\n\n    <h1 id=\"synchronous-javascript\">Synchronous Javascript</h1>\n\n    <p>\n        Trước khi đi sâu vào asynchronous JavaScript, ta cần hiểu cách mà\n        synchronous JavaScript code được thực thi trong JavaScript engine. Ví dụ:\n    </p>\n\n    <pre><code class=\"language-javascript\">const second = () =&gt; {\n    console.log('Hello there!');\n}\nconst first = () =&gt; {\n    console.log('Hi there!');\n    second();\n    console.log('The End');\n}\nfirst();\n</code></pre>\n\n    <p>\n        Để hiểu đoạn code trên được thực thi như thế nào trong JavaScript engine,\n        chúng ta phải hiểu khái niệm về <strong>execution context</strong> và\n        <strong>call stack</strong>.\n    </p>\n\n    <h2 id=\"execution-context\">Execution Context</h2>\n\n    <p>\n        <strong>Execution Context</strong> là một khái niệm trừu tượng về môi trường\n        nơi JavaScript code được đánh giá và thực hiện. Bất cứ khi nào code được\n        thực thi trong JavaScript, nó chạy trong một <em>execution context</em>.\n    </p>\n\n    <p>\n        Code global thực thi trong một global execution context, và code toàn cục\n        thực hiện trong một local execution context toàn cục. Mỗi hàm có một\n        execution context riêng của nó.\n    </p>\n\n    <h2 id=\"call-stack\">Call Stack</h2>\n\n    <p>\n        <strong>Call stack</strong> như tên gọi của nó là một stack với cấu trúc\n        <em>LIFO (Last in First out)</em> được sử dụng để lưu trữ tất cả các\n        execution context được tạo ra trong quá trình thực thi code.\n    </p>\n\n    <blockquote>\n        <p>\n            JavaScript có một call stack duy nhất vì nó là một ngôn ngữ lập trình đơn\n            luồng. Call Stack có cấu trúc LIFO nghĩa là các mục chỉ có thể được thêm\n            hoặc xóa khỏi đầu stack.\n        </p>\n    </blockquote>\n\n    <p>\n        Hãy quay lại đoạn mã trên và tìm hiểu cách code được thực thi bên trong\n        JavaScript engine.\n    </p>\n\n    <figure>\n        <img\n                src=\"https://i.postimg.cc/523LSZ88/e6a202c0-2dbc-4ec0-af91-0fc89500fb72.webp\"\n                alt=\"Call stack\"\n        />\n        <figcaption>Call stack khi chạy đoạn code trên</figcaption>\n    </figure>\n\n    <ul>\n        <li>\n            <p>Khi đoạn code trên được thực thi, một\n                <em>local execution context</em> được tạo ra (biểu diễn bằng hàm\n                <code>main()</code>) và được đẩy vào đầu stack. Khi hàm\n                <code>first()</code> được gọi, nó được đẩy vào đầu stack.</p>\n        </li>\n        <li>\n            <p>\n                Tiếp theo, <code>console.log('Hi there!')</code> được đẩy vào đầu stack,\n                khi kết thúc, nó được lấy ra từ stack. Sau đó hàm\n                <code>second()</code> được gọi và nó được đẩy vào đầu của stack.\n            </p>\n\n        </li>\n        <li>\n            <p>\n            <code>console.log('Hello there!')</code> được đẩy vào đầu stack là lấy\n            ra khi nó kết thúc. Hàm <code>second()</code> kết thúc, do đó nó được\n            lấy ra khỏi stack.</p>\n        </li>\n        <li>\n            <p><code>console.log(‘The End’)</code> được đẩy vào đầu của stack và xóa đi\n            khi nó kết thúc. Sau đó, hàm <code>first()</code> kết thúc và nó được\n            lấy ra khỏi stack.</p>\n        </li>\n        <li>\n            <p>Chương trình thực hiện xong ở đây và\n            <em>local execution context</em> (<code>main()</code>) được lấy ra khỏi\n            stack.</p>\n        </li>\n    </ul>\n\n    <p>\n        Đến đây ta đã có ý tưởng cơ bản về <strong>call stack</strong> và JavaScript\n        đồng bộ hoạt động như thế nào, hãy quay trở lại với JavaScript bất đồng bộ.\n    </p>\n\n    <h1 id=\"asynchronous-javascript\">Asynchronous Javascript</h1>\n\n    <h2 id=\"blocking\">Blocking</h2>\n\n    <p>\n        Giả sử ta đang xử lý hình ảnh hay thực hiện network request theo cách đồng\n        bộ:\n    </p>\n\n    <pre><code class=\"language-javascript\">const processImage = (image) =&gt; {\n/**\n* doing some operations on image\n**/\nconsole.log('Image processed');\n}\nconst networkRequest = (url) =&gt; {\n/**\n* requesting network resource\n**/\nreturn someData;\n}\nconst greeting = () =&gt; {\nconsole.log('Hello World');\n}\nprocessImage(logo.jpg);\nnetworkRequest('www.somerandomurl.com');\ngreeting();\n</code></pre>\n\n    <p>\n        Việc xử lý hình ảnh và network request cần có thời gian. Vì vậy, khi hàm\n        <code>processImage()</code> được gọi, sẽ mất một chút thời gian tùy thuộc\n        vào kích thước của hình ảnh.\n    </p>\n\n    <p>\n        Khi hàm <code>processImage()</code> hoàn thành, nó sẽ bị xóa khỏi stack, sau\n        đó hàm <code>networkRequest()</code> được gọi và được đẩy vào stack, một lần\n        nữa cũng sẽ mất một thời gian để nó thực thi xong.\n    </p>\n\n    <p>\n        Cuối cùng khi hàm <code>networkRequest()</code> hoàn thành, hàm\n        <code>greeting()</code> được gọi và nó chỉ thực thi một câu lệnh\n        <code>console.log</code> và các câu lệnh <code>console.log</code> nói chung\n        là nhanh, do đó hàm <code>greeting()</code> thực hiện xong ngay lập tức và\n        kết thúc.\n    </p>\n\n    <p>\n        Như đã thấy, chúng ta phải chờ các hàm <code>processImage()</code> và\n        <code>networkRequest()</code> kết thúc. Điều này có nghĩa là các hàm này\n        đang chặn <strong>call stack</strong> hay luồng chính. Do đó chúng ta không\n        thể thực hiện hoạt động khác khi code trên đang thực hiện.\n    </p>\n\n    <h2 id=\"giai-phap-cho-blocking\">Giải pháp cho blocking</h2>\n\n    <p>\n        Giải pháp đơn giản nhất là <strong>callbacks không đồng bộ</strong>. Ta sử\n        dụng asynchronous callbacks để làm cho code trở thành\n        <strong>non-blocking</strong>. Ví dụ:\n    </p>\n\n    <pre><code class=\"language-javascript\">const networkRequest = () =&gt; {\n    setTimeout(() =&gt; {\n        console.log('Async Code');\n    }, 2000);\n};\nconsole.log('Hello World');\nnetworkRequest();\n</code></pre>\n\n    <p>\n        Ở đây, phương thức <code>setTimeout</code> được sử dụng để mô phỏng network\n        request. Cần nhớ rằng <code>setTimeout</code> không phải là một phần của\n        Javascript engine. Nó là một phần của web APIs và C/C++ APIs.\n    </p>\n\n    <p>\n        Để hiểu đoạn code này được thực thi như thế nào, chúng ta cần hiểu một vài\n        khái niệm khác như <strong>event loop</strong> và\n        <strong>callback queue</strong> (hay <em>message queue</em>)\n    </p>\n\n    <figure>\n        <img\n                src=\"https://i.postimg.cc/yxcv1vtn/97f2b2fc-d251-489e-ab2e-f799a0803931.webp\"\n                alt=\"Event loop và Callback queue\"\n                title=\"\"\n        />\n        <figcaption>Event loop và Message queue</figcaption>\n    </figure>\n\n    <p>\n        <code>event loop</code>, <code>web APIs</code> và\n        <code>message queue</code> không phải là một phần của JavaScript engine, nó\n        là một phần của môi trường thực thi Javascript của browser hay môi trường\n        thực thi Nodejs JavaScript (trong trường hợp Nodejs). Trong Nodejs, web APIs\n        được thay thế bởi C/C++ APIs.\n    </p>\n\n    <p>\n        Bây giờ hãy trở lại với đoạn code trên và xem xét nó được thực thi như thế\n        nào theo cách bất đồng bộ:\n    </p>\n\n    <pre><code class=\"language-javascript\">const networkRequest = () =&gt; {\n    setTimeout(() =&gt; {\n        console.log('Async Code');\n    }, 2000);\n};\nconsole.log('Hello World');\nnetworkRequest();\nconsole.log('The End');\n</code></pre>\n\n    <figure>\n        <img\n                src=\"https://i.postimg.cc/28YRybpq/d6668078-23db-42d3-b311-ea0a97dbd6e6.gif\"\n                alt=\"Event loop và Callback queue\"\n                title=\"\"\n        />\n        <figcaption>Event loop và Message queue bất đồng bộ</figcaption>\n    </figure>\n\n    <p>\n        Khi đoạn code trên được load vào trình duyệt,\n        <code>console.log(‘Hello World’)</code> được đẩy vào stack và lấy ra khi nó\n        kết thúc. Tiếp theo, <code>hàm networkRequest()</code> được gọi và nó được\n        đẩy vào đầu stack.\n    </p>\n\n    <p>\n        Tiếp theo, hàm <code>setTimeout()</code> được gọi, nó được đẩy vào đầu\n        stack. Hàm <code>setTimeout()</code> có hai tham số 1) callback và 2) thời\n        gian với đơn vị mili giây.\n    </p>\n\n    <p>\n        Hàm <code>setTimeout()</code> bắt đầu hẹn giờ 2s trong môi trường web APIs.\n        Tại thời điểm này, <code>setTimeout()</code> kết thúc và được lấy ra khỏi\n        stack. Sau đó <code>console.log('The End')</code> được đẩy vào stack, thực\n        thi và xóa khỏi stack sau khi nó hoàn tất.\n    </p>\n\n    <p>\n        Trong khi đó, bộ hẹn giờ đến hạn và <code>callback</code> được đẩy vào\n        <strong>message queue</strong>. Nhưng <code>callback</code> không được thực\n        hiện ngay lập tức và đó là nơi <strong>event loop</strong> được khởi động.\n    </p>\n\n    <h2 id=\"event-loop\">Event Loop</h2>\n\n    <p>\n        Công việc của <strong>event loop</strong> là nhìn vào\n        <strong>call stack</strong> và xác định xem call stack có trống hay không.\n        Nếu call stack trống, nó sẽ nhìn vào <strong>mesage queue</strong> để xem có\n        bất kỳ <code>callback</code> nào đang chờ xử lý để thực hiện nó.\n    </p>\n\n    <p>\n        Trong trường hợp này, message queue có chứa 1 <code>callback</code> còn call\n        stack thì trống rỗng. Do đó event loop đẩy <code>callback</code> vào đầu\n        stack.\n    </p>\n\n    <p>\n        <code>console.log(‘Async Code’)</code> được đẩy vào đầu stack, thực thi và\n        lấy ra khỏi stack. Tại đây, <code>callback</code> kết thúc và được lấy ra\n        khỏi stack và chương trình kết thúc.\n    </p>\n\n    <p>\n        Message queue cũng chứa các <code>callback</code> từ các DOM events như\n        event click và event keyboard. Ví dụ:\n    </p>\n\n    <pre><code class=\"language-javascript\">document.querySelector('.btn').addEventListener('click',(event) =&gt; {\n    console.log('Button Clicked');\n});\n</code></pre>\n\n    <p>\n        Trong trường hợp DOM events, <em>event listener</em> đặt ở môi trường web\n        APIs chờ một event cụ thể xảy ra. Và khi nó xảy ra, hàm\n        <code>callback</code> được đặt vào message queue và chờ được thực thi. Một\n        lần nữa event loop sẽ kiểm tra xem call stack có trống không và đẩy\n        <code>callback</code> vào stack nếu nó trống và <code>callback</code> được\n        thực thi.\n    </p>\n\n    <h2 id=\"delay-thuc-thi-ham\">Delay thực thi hàm</h2>\n\n    <p>\n        Chúng ta cũng có thể sử dụng <code>setTimeout</code> để trì hoãn việc thực\n        thi hàm cho đến khi stack trống. Ví dụ:\n    </p>\n\n    <pre><code class=\"language-javascript\">const bar = () =&gt; {\n    console.log('bar');\n}\nconst baz = () =&gt; {\n    console.log('baz');\n}\nconst foo = () =&gt; {\n    console.log('foo');\n    setTimeout(bar, 0);\n    baz();\n}\nfoo();\n</code></pre>\n\n    <p>Kết quả là:</p>\n    <pre><code class=\"language-javascript\">foo\nbaz\nbar\n</code></pre>\n\n    <p>\n        Khi code này chạy, đầu tiên <code>foo()</code> được gọi, bên trong foo chúng\n        ta gọi <code>console.log('foo')</code>, sau đó\n        <code>setTimeout()</code> được gọi với <code>bar()</code> là\n        <code>callback</code> và bộ đếm thời gian 0 giây.\n    </p>\n\n    <p>\n        Bây giờ nếu chúng ta không sử dụng <code>setTimeout</code>, hàm\n        <code>bar()</code> sẽ được thực hiện ngay lập tức, nhưng việc sử dụng\n        <code>setTimeout</code> với bộ đếm thời gian 0 giây giúp trì hoãn việc thực\n        hiện <code>bar()</code> cho đến khi stack trống.\n    </p>\n\n    <p>\n        Sau 0 giây, <code>callback</code> <code>bar ()</code> được đưa vào message\n        queue đang đợi để được thực thi. Nhưng nó sẽ chỉ được thực hiện khi stack\n        hoàn toàn trống rỗng sau khi hàm <code>baz</code> và <code>foo</code> kết\n        thúc.\n    </p>\n\n    <h2 id=\"es6-job-queue\">ES6 Job Queue</h2>\n\n    <p>\n        Chúng ta đã học được cách các <code>callback</code> không đồng bộ và các DOM\n        events được thực thi, sử dụng message queue để lưu trữ tất cả các\n        <code>callback</code> chờ đợi để được thực thi.\n    </p>\n\n    <p>\n        <strong><a href=\"http://es6-features.org/\" target=\"_blank\">ES6</a></strong> giới thiệu khái\n        niệm về <strong>job queue</strong> được sử dụng bởi\n        <strong>Promises</strong> trong JavaScript.\n    </p>\n\n    <blockquote>\n        <p>\n            Sự khác biệt giữa message queue và job queue là job queue có mức ưu tiên\n            cao hơn message queue, có nghĩa là các <em>promise job</em> bên trong job\n            queue sẽ được <strong>thực thi trước</strong> các <em>callback</em> bên\n            trong message queue.\n        </p>\n    </blockquote>\n\n    <p>Ví dụ:</p>\n\n    <pre><code class=\"language-javascript\">const bar = () =&gt; {\n    console.log('bar');\n};\nconst baz = () =&gt; {\n    console.log('baz');\n};\nconst foo = () =&gt; {\n    console.log('foo');\n    setTimeout(bar, 0);\n    new Promise((resolve, reject) =&gt; {\n        resolve('Promise resolved');\n    }).then(res =&gt; console.log(res))\n    .catch(err =&gt; console.log(err));\n    baz();\n};\nfoo();\n</code></pre>\n    <p>Kết quả là:</p>\n    <pre><code class=\"language-javascript\">foo\nbaz\nPromised resolved\nbar\n</code></pre>\n\n    <p>\n        Chúng ta có thể thấy rằng <code>promise</code> được thực hiện trước\n        <code>setTimeout</code>, bởi vì <code>promise</code> response được lưu trữ\n        bên trong job queue có mức độ ưu tiên cao hơn message queue.\n    </p>\n\n    <h1 id=\"ket-luan\">Kết luận</h1>\n\n    <p>\n        Chúng ta đã học được cách JavaScript không đồng bộ hoạt động và các khái\n        niệm khác như call stack, event loop, message queue và job queue cùng nhau\n        tạo ra môi trường chạy JavaScript. Những khái niệm này rất hữu ích và quan\n        trọng để bạn học hỏi sâu hơn về Javascript, đặc biệt là khi sử dụng NodeJS.\n    </p>\n</div>\n",
  "authorName": "Tu Bui",
  "timeRelease": "2021-11-02T13:40:50Z",
  "timeCreate": "2021-11-02T02:21:50Z",
  "title": "Hiểu về Cơ chế Bất đồng bộ Asynchronous JavaScript",
  "subTitle": "Sử dụng asynchronous JavaScript (callbacks, promises, and async/await) bạn có thể thực hiện các request network dài mà không chặn luồng chính.",
  "coverImgUrl": "https://i.postimg.cc/1X0RxN2h/sv-2.jpg",
  "thumbnailImgUrl": "https://i.postimg.cc/28YRybpq/d6668078-23db-42d3-b311-ea0a97dbd6e6.gif",
  "blogTag": ["Javascript", "Web Development"]
}