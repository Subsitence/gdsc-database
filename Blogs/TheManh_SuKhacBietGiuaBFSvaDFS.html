<div class="post-body">
    <h1 id="su-khac-biet-giua-bfs-va-dfs">Sự khác biệt giữa BFS và DFS</h1>
    <p>
        Sự khác biệt chính giữa BFS và DFS là BFS tiến hành theo cấp độ trong khi DFS theo sau một đường dẫn từ nút bắt
        đầu đến nút kết thúc (đỉnh),
        sau đó là một đường dẫn khác từ đầu đến cuối, và cho đến khi tất cả các nút được truy cập.
        Hơn nữa, BFS sử dụng hàng đợi để lưu trữ các nút trong khi DFS sử dụng ngăn xếp để duyệt qua các nút.
    </p>
    <p>
        BFS và DFS là các phương thức di chuyển ngang được sử dụng trong tìm kiếm đồ thị.
        Biểu đồ truyền tải là quá trình truy cập tất cả các nút của biểu đồ.
        Biểu đồ là một nhóm các đỉnh &#x27;V&#x27; và Edges &#x27;E&#x27; kết nối với các đỉnh.
    </p>
    <h1 id="dinh=nghia-cua-bfs">Định nghĩa của BFS</h1>
    <p><strong>Breadth First Search (BFS)</strong>
        là phương pháp di chuyển ngang được sử dụng trong biểu đồ.
        Nó sử dụng một hàng đợi để lưu trữ các đỉnh đã truy cập.
        Trong phương pháp này, phần nhấn mạnh nằm trên các đỉnh của đồ thị, một đỉnh được chọn lúc đầu sau đó được truy
        cập và đánh dấu.
        Các đỉnh liền kề với đỉnh được truy cập sau đó được truy cập và lưu trữ trong hàng đợi một cách tuần tự. Tương
        tự, các đỉnh được lưu trữ sau đó được xử lý từng cái một và các đỉnh liền kề của chúng được truy cập.
        Một nút được khám phá đầy đủ trước khi truy cập bất kỳ nút nào khác trong biểu đồ, nói cách khác, nó đi qua các
        nút chưa được khám phá nông nhất trước tiên.
    </p>
    <figure>
        <img src="https://upload.wikimedia.org/wikipedia/commons/4/46/Animated_BFS.gif"/>
    </figure>
    <pre>
            <code class="language-java">
                import java.util.LinkedList;
                import java.util.Queue;
                class BreadthFistSearch{
                    //  Breadth-First Search with directed graphs 
                    //  The problem is to find out if there is a path from one vertex to another
                    static boolean BFS(int a, int b, int[][] G, int n){
                        Queue&lt;Integer&gt; fringer = new LinkedList&lt;&gt;();
                        Queue&lt;Integer&gt; close = new LinkedList&lt;&gt;();
                        fringer.add(a); // push a in the queue
                        while(fringer.peek() != null){    // return &quot;null&quot; if queue = hollow
                            int direct = fringer.poll();
                            if(direct == b){
                                return true;
                            }else{
                                close.add(direct);
                            }
                            for(int i = 0; i &lt; G.length; i++){
                                if(G[i][0] == direct){
                                    fringer.add(G[i][1]);
                                }
                            }
                        }
                        return false;
                    }
                    public static void main(String[] args) {
                        int n = 8;    // Number of vertices given by the problem
                        int[][] G = {{1,2}, {1,3}, {2,4}, {2,5}, {3,6}, {3,7}, {5,8}}; //Array g stores the paths of the vertices 
                        System.out.println(BFS(3, 4, G, n));    // result : false
                        System.out.println(BFS(1, 7, G, n));    // result : true
                    }
                }
            </code>
        </pre>
    <h1 id="dinh-nghia-cua-dfs">Định nghĩa của DFS</h1>
    <p>
        Phương pháp di chuyển ngang <strong>tìm kiếm sâu (DFS)</strong>
        sử dụng ngăn xếp để lưu trữ các đỉnh đã truy cập. DFS là phương pháp dựa trên cạnh và hoạt động theo kiểu đệ quy
        trong đó các đỉnh được khám phá dọc theo một đường dẫn (cạnh).
        Việc thăm dò một nút bị đình chỉ ngay khi tìm thấy một nút chưa được khám phá khác và các nút chưa được khám phá
        sâu nhất được duyệt qua trước hết.
        DFS di chuyển / truy cập mỗi đỉnh chính xác một lần và mỗi cạnh được kiểm tra chính xác hai lần.
    </p>
    <figure>
        <img src="https://wiki.gladiabots.com/images/7/7f/Depth-First-Search.gif"/>
    </figure>
    <pre>
            <code class="language-java">
                import java.util.Stack;
                public class Depthfirstsearch {
                static boolean DFS(int a, int b, int[][] G){
                    Stack&lt;Integer&gt; fringer = new Stack&lt;&gt;();
                    Stack&lt;Integer&gt; close = new Stack&lt;&gt;();
                    fringer.push(a);    // push a in the queue
                    while(!fringer.empty()){    // return &quot;null&quot; if queue = hollow
                        int direct = fringer.pop();
                        if(direct == b) {
                            return true;
                        } else {
                            close.push(direct);
                        }
                        for(int i = 0; i &lt; G.length; i++) {
                            if(G[i][0] == direct){
                                fringer.push(G[i][1]);
                            }
                        }
                    }
                    return false;
                }
                public static void main(String[] args) {
                    int n = 8;    // Number of vertices given by the problem
                    int[][] G = {{1,2}, {1,3}, {2,4}, {2,5}, {3,6}, {3,7}, {5,8}}; //Array g stores the paths of the vertices 
                    
                    System.out.println(DFS(1, 8, G));    // result : true
                    System.out.println(DFS(2, 7, G));    // result : false
                }
            }
            </code>
        </pre>
    <blockquote>
        <h1 id="su-khac-biet-chinh-giua-bfs-va-dfs"><strong>Sự khác biệt chính giữa BFS và DFS</strong></h1>
        <ul>
            <li>BFS là thuật toán dựa trên đỉnh trong khi DFS là thuật toán dựa trên cạnh.</li>
            <li>Cấu trúc dữ liệu hàng đợi được sử dụng trong BFS. Mặt khác, DFS sử dụng stack hoặc đệ quy.</li>
            <li>Không gian bộ nhớ được sử dụng hiệu quả trong DFS trong khi sử dụng không gian trong BFS không hiệu
                quả.
            </li>
            <li>BFS là thuật toán tối ưu trong khi DFS không tối ưu.</li>
            <li>DFS xây dựng cây hẹp và dài. Như chống lại, BFS xây dựng cây rộng và ngắn.</li>
        </ul>
    </blockquote>
    <h1 id="ket-luan">Kết Luận</h1>
    <p>BFS và DFS, cả hai kỹ thuật tìm kiếm đồ thị có thời gian chạy tương tự nhưng tiêu thụ không gian khác nhau,
        DFS chiếm không gian tuyến tính vì chúng ta phải nhớ đường dẫn đơn với các nút chưa được khám phá,
        trong khi BFS giữ mọi nút trong bộ nhớ.
    </p>
    <p>DFS mang lại giải pháp sâu hơn và không tối ưu, nhưng nó hoạt động tốt khi giải pháp dày đặc trong khi BFS là tối
        ưu để tìm kiếm mục tiêu tối ưu lúc đầu.</p>
</div>